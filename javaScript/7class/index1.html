<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //class 만들기
        //class : 어떤 데이타(변수, 메서드)가 있어야 하는지를 정의하는 틀
        //클래스가 붕어빵틀이면 객체(인스턴스)는 붕어빵이다.

        //클래스의 이름은 대문자로 시작한다.(개발자끼리의 약속)
        //constructor --> 생성자, 클래스가 실행될 때 바로 실행되고 한번만 실행된다.
        class Person{
            name="홍길동";
            year=2002;
        }

        let man=new Person();
        console.log(man)

        let man2=new Person();
        console.log(man2)

        class Person2{
            name; //🧡
            year;

            constructor(name,year){
                this.name= name;  //this.class Person2 안 name🧡 = constructor (name)
                this.year= year;
            }
            //메서드 만들기 함수이름(){}(function 키를 적지 않음)
            sayname() {
                return `안녕~ 나의 이름은 ${this.name}라고 해~`
            }
        }
        
        let man3=new Person2("강감찬",2004)
        console.log(man3)//Person2 {name: '강감찬', year: 2004}
        let man4=new Person2("이순신",2008)
        console.log(man4)//Person2 {name: '이순신', year: 2008}
        let man5=new Person2("세종대왕",2010)
        console.log(man5)//Person2 {name: '세종대왕', year: 2010}
        console.log(man5.sayname())//안녕~ 나의 이름은 세종대왕라고 해~


        console.log(man3.name)//강감찬
        console.log(man5.year)//2010
        console.log(Person2.prototype)

        console.log(typeof Person2)//function//클래스는 함수다.
        //클래스의 타입 체크를 했을 때 function으로 찍히는 이유

        //클래스 선언문은 아래와 같은 내부 동작을 수행
        
        // 1. Person2 이름의 함수를 생성
        // 2. 이 함수의 본문은 class의 constructor를 그대로 가져온다. 만약, constructor가 없으면 빈 함수를 생성
        // 3. 메서드가 같은 이름의 Person2.prototype(프로토타입 객체, 원형)에 추가
        // 4. 결국 "프로토타입 객체"쪽에 클래스내에 정의한 메서드들을 추가해 놓는 것이기 때문에, 해당 클래스의 인스턴스(객체)가 생성되면 추가된 메서드를 자유롭게 이용할 수 있는 것이다.


    </script>
</body>
</html>